// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SERIALIZATION_KRYPTO_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_SERIALIZATION_KRYPTO_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace krypto {
namespace serialization {

struct Empty;
struct EmptyBuilder;

struct SequenceNumber;
struct SequenceNumberBuilder;

struct Heartbeat;
struct HeartbeatBuilder;

struct Instrument;
struct InstrumentBuilder;

struct Quote;
struct QuoteBuilder;

struct SnapshotPriceLevel;

struct Snapshot;
struct SnapshotBuilder;

struct IncrementalPriceLevel;

struct Incremental;
struct IncrementalBuilder;

struct Trade;
struct TradeBuilder;

struct InstrumentRequest;
struct InstrumentRequestBuilder;

struct InstrumentResponse;
struct InstrumentResponseBuilder;

struct InstrumentRefreshRequest;
struct InstrumentRefreshRequestBuilder;

struct OrderRequest;
struct OrderRequestBuilder;

struct OrderCancelRequest;
struct OrderCancelRequestBuilder;

struct OrderReplaceRequest;
struct OrderReplaceRequestBuilder;

struct OrderUpdate;
struct OrderUpdateBuilder;

struct Order;
struct OrderBuilder;

struct Position;

struct TraderPosition;
struct TraderPositionBuilder;

struct BookPosition;
struct BookPositionBuilder;

struct RiskSummary;
struct RiskSummaryBuilder;

struct RiskSummaryRequest;
struct RiskSummaryRequestBuilder;

struct TheoreticalSnapshot;
struct TheoreticalSnapshotBuilder;

enum Exchange {
  Exchange_SIM = 0,
  Exchange_COINBASE = 1,
  Exchange_MIN = Exchange_SIM,
  Exchange_MAX = Exchange_COINBASE
};

inline const Exchange (&EnumValuesExchange())[2] {
  static const Exchange values[] = {
    Exchange_SIM,
    Exchange_COINBASE
  };
  return values;
}

inline const char * const *EnumNamesExchange() {
  static const char * const names[3] = {
    "SIM",
    "COINBASE",
    nullptr
  };
  return names;
}

inline const char *EnumNameExchange(Exchange e) {
  if (flatbuffers::IsOutRange(e, Exchange_SIM, Exchange_COINBASE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExchange()[index];
}

enum Side {
  Side_UNKNOWN = 0,
  Side_BUY = 1,
  Side_SELL = 2,
  Side_MIN = Side_UNKNOWN,
  Side_MAX = Side_SELL
};

inline const Side (&EnumValuesSide())[3] {
  static const Side values[] = {
    Side_UNKNOWN,
    Side_BUY,
    Side_SELL
  };
  return values;
}

inline const char * const *EnumNamesSide() {
  static const char * const names[4] = {
    "UNKNOWN",
    "BUY",
    "SELL",
    nullptr
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  if (flatbuffers::IsOutRange(e, Side_UNKNOWN, Side_SELL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSide()[index];
}

enum OrderSide {
  OrderSide_UNKNOWN = 0,
  OrderSide_BID = 1,
  OrderSide_ASK = 2,
  OrderSide_MIN = OrderSide_UNKNOWN,
  OrderSide_MAX = OrderSide_ASK
};

inline const OrderSide (&EnumValuesOrderSide())[3] {
  static const OrderSide values[] = {
    OrderSide_UNKNOWN,
    OrderSide_BID,
    OrderSide_ASK
  };
  return values;
}

inline const char * const *EnumNamesOrderSide() {
  static const char * const names[4] = {
    "UNKNOWN",
    "BID",
    "ASK",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrderSide(OrderSide e) {
  if (flatbuffers::IsOutRange(e, OrderSide_UNKNOWN, OrderSide_ASK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderSide()[index];
}

enum OrderStatus {
  OrderStatus_UNKNOWN = 0,
  OrderStatus_IN_FLIGHT = 1,
  OrderStatus_CANCEL_IN_FLIGHT = 2,
  OrderStatus_REPLACE_IN_FLIGHT = 3,
  OrderStatus_NEW = 4,
  OrderStatus_ACCEPTED = 5,
  OrderStatus_CANCELLED = 6,
  OrderStatus_REPLACED = 7,
  OrderStatus_REJECTED = 8,
  OrderStatus_CANCEL_REJECTED = 9,
  OrderStatus_REPLACE_REJECTED = 10,
  OrderStatus_FILLED = 11,
  OrderStatus_PARTIALLY_FILLED = 12,
  OrderStatus_EXPIRED = 13,
  OrderStatus_DONE = 14,
  OrderStatus_MIN = OrderStatus_UNKNOWN,
  OrderStatus_MAX = OrderStatus_DONE
};

inline const OrderStatus (&EnumValuesOrderStatus())[15] {
  static const OrderStatus values[] = {
    OrderStatus_UNKNOWN,
    OrderStatus_IN_FLIGHT,
    OrderStatus_CANCEL_IN_FLIGHT,
    OrderStatus_REPLACE_IN_FLIGHT,
    OrderStatus_NEW,
    OrderStatus_ACCEPTED,
    OrderStatus_CANCELLED,
    OrderStatus_REPLACED,
    OrderStatus_REJECTED,
    OrderStatus_CANCEL_REJECTED,
    OrderStatus_REPLACE_REJECTED,
    OrderStatus_FILLED,
    OrderStatus_PARTIALLY_FILLED,
    OrderStatus_EXPIRED,
    OrderStatus_DONE
  };
  return values;
}

inline const char * const *EnumNamesOrderStatus() {
  static const char * const names[16] = {
    "UNKNOWN",
    "IN_FLIGHT",
    "CANCEL_IN_FLIGHT",
    "REPLACE_IN_FLIGHT",
    "NEW",
    "ACCEPTED",
    "CANCELLED",
    "REPLACED",
    "REJECTED",
    "CANCEL_REJECTED",
    "REPLACE_REJECTED",
    "FILLED",
    "PARTIALLY_FILLED",
    "EXPIRED",
    "DONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrderStatus(OrderStatus e) {
  if (flatbuffers::IsOutRange(e, OrderStatus_UNKNOWN, OrderStatus_DONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderStatus()[index];
}

enum TimeInForce {
  TimeInForce_DAY = 0,
  TimeInForce_IOC = 1,
  TimeInForce_FOK = 2,
  TimeInForce_GTC = 3,
  TimeInForce_GTT = 4,
  TimeInForce_MIN = TimeInForce_DAY,
  TimeInForce_MAX = TimeInForce_GTT
};

inline const TimeInForce (&EnumValuesTimeInForce())[5] {
  static const TimeInForce values[] = {
    TimeInForce_DAY,
    TimeInForce_IOC,
    TimeInForce_FOK,
    TimeInForce_GTC,
    TimeInForce_GTT
  };
  return values;
}

inline const char * const *EnumNamesTimeInForce() {
  static const char * const names[6] = {
    "DAY",
    "IOC",
    "FOK",
    "GTC",
    "GTT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeInForce(TimeInForce e) {
  if (flatbuffers::IsOutRange(e, TimeInForce_DAY, TimeInForce_GTT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeInForce()[index];
}

enum InstrumentType {
  InstrumentType_UNKNOWN = 0,
  InstrumentType_STOCK = 1,
  InstrumentType_FUTURE = 2,
  InstrumentType_OPTION = 3,
  InstrumentType_FOREX = 4,
  InstrumentType_CRYPTO = 5,
  InstrumentType_MIN = InstrumentType_UNKNOWN,
  InstrumentType_MAX = InstrumentType_CRYPTO
};

inline const InstrumentType (&EnumValuesInstrumentType())[6] {
  static const InstrumentType values[] = {
    InstrumentType_UNKNOWN,
    InstrumentType_STOCK,
    InstrumentType_FUTURE,
    InstrumentType_OPTION,
    InstrumentType_FOREX,
    InstrumentType_CRYPTO
  };
  return values;
}

inline const char * const *EnumNamesInstrumentType() {
  static const char * const names[7] = {
    "UNKNOWN",
    "STOCK",
    "FUTURE",
    "OPTION",
    "FOREX",
    "CRYPTO",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstrumentType(InstrumentType e) {
  if (flatbuffers::IsOutRange(e, InstrumentType_UNKNOWN, InstrumentType_CRYPTO)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInstrumentType()[index];
}

enum Currency {
  Currency_UNKNOWN = 0,
  Currency_BAT = 1,
  Currency_BCH = 2,
  Currency_BTC = 3,
  Currency_CVC = 4,
  Currency_DAI = 5,
  Currency_DNT = 6,
  Currency_EOS = 7,
  Currency_ETC = 8,
  Currency_ETH = 9,
  Currency_EUR = 10,
  Currency_GBP = 11,
  Currency_GNT = 12,
  Currency_LINK = 13,
  Currency_LOOM = 14,
  Currency_LTC = 15,
  Currency_MANA = 16,
  Currency_REP = 17,
  Currency_USD = 18,
  Currency_USDC = 19,
  Currency_XLM = 20,
  Currency_XRP = 21,
  Currency_ZEC = 22,
  Currency_ZRX = 23,
  Currency_XTZ = 24,
  Currency_ALGO = 25,
  Currency_DASH = 26,
  Currency_OXT = 27,
  Currency_ATOM = 28,
  Currency_KNC = 29,
  Currency_OMG = 30,
  Currency_MKR = 31,
  Currency_WBTC = 32,
  Currency_NU = 33,
  Currency_YFI = 34,
  Currency_BAND = 35,
  Currency_UMA = 36,
  Currency_NMR = 37,
  Currency_FIL = 38,
  Currency_CGLD = 39,
  Currency_LRC = 40,
  Currency_COMP = 41,
  Currency_UNI = 42,
  Currency_REN = 43,
  Currency_BAL = 44,
  Currency_GRT = 45,
  Currency_BNT = 46,
  Currency_AAVE = 47,
  Currency_SNX = 48,
  Currency_WLUNA = 49,
  Currency_DOGE = 50,
  Currency_RAD = 51,
  Currency_GTC = 52,
  Currency_TRU = 53,
  Currency_SUSHI = 54,
  Currency_SKL = 55,
  Currency_COTI = 56,
  Currency_REQ = 57,
  Currency_FORTH = 58,
  Currency_ENJ = 59,
  Currency_USDT = 60,
  Currency_DOT = 61,
  Currency_CHZ = 62,
  Currency_UST = 63,
  Currency_MASK = 64,
  Currency_DDX = 65,
  Currency_SOL = 66,
  Currency_RLY = 67,
  Currency_AXS = 68,
  Currency_ADA = 69,
  Currency_STORJ = 70,
  Currency_ICP = 71,
  Currency_IOTX = 72,
  Currency_CRV = 73,
  Currency_FET = 74,
  Currency_POLY = 75,
  Currency_MKN = 76,
  Currency_MIR = 77,
  Currency_PAX = 78,
  Currency_MATIC = 79,
  Currency_ANKR = 80,
  Currency_OGN = 81,
  Currency_RLC = 82,
  Currency_TRB = 83,
  Currency_ORN = 84,
  Currency_CTSI = 85,
  Currency_YFII = 86,
  Currency_BOND = 87,
  Currency_CLV = 88,
  Currency_TRIBE = 89,
  Currency_ACH = 90,
  Currency_PLA = 91,
  Currency_QUICK = 92,
  Currency_MLN = 93,
  Currency_QNT = 94,
  Currency_LPT = 95,
  Currency_KEEP = 96,
  Currency_RAI = 97,
  Currency_NKN = 98,
  Currency_AMP = 99,
  Currency_FARM = 100,
  Currency_SHIB = 101,
  Currency_XYO = 102,
  Currency_RGT = 103,
  Currency_BTRST = 104,
  Currency_AGLD = 105,
  Currency_ZEN = 106,
  Currency_MIN = Currency_UNKNOWN,
  Currency_MAX = Currency_ZEN
};

inline const Currency (&EnumValuesCurrency())[107] {
  static const Currency values[] = {
    Currency_UNKNOWN,
    Currency_BAT,
    Currency_BCH,
    Currency_BTC,
    Currency_CVC,
    Currency_DAI,
    Currency_DNT,
    Currency_EOS,
    Currency_ETC,
    Currency_ETH,
    Currency_EUR,
    Currency_GBP,
    Currency_GNT,
    Currency_LINK,
    Currency_LOOM,
    Currency_LTC,
    Currency_MANA,
    Currency_REP,
    Currency_USD,
    Currency_USDC,
    Currency_XLM,
    Currency_XRP,
    Currency_ZEC,
    Currency_ZRX,
    Currency_XTZ,
    Currency_ALGO,
    Currency_DASH,
    Currency_OXT,
    Currency_ATOM,
    Currency_KNC,
    Currency_OMG,
    Currency_MKR,
    Currency_WBTC,
    Currency_NU,
    Currency_YFI,
    Currency_BAND,
    Currency_UMA,
    Currency_NMR,
    Currency_FIL,
    Currency_CGLD,
    Currency_LRC,
    Currency_COMP,
    Currency_UNI,
    Currency_REN,
    Currency_BAL,
    Currency_GRT,
    Currency_BNT,
    Currency_AAVE,
    Currency_SNX,
    Currency_WLUNA,
    Currency_DOGE,
    Currency_RAD,
    Currency_GTC,
    Currency_TRU,
    Currency_SUSHI,
    Currency_SKL,
    Currency_COTI,
    Currency_REQ,
    Currency_FORTH,
    Currency_ENJ,
    Currency_USDT,
    Currency_DOT,
    Currency_CHZ,
    Currency_UST,
    Currency_MASK,
    Currency_DDX,
    Currency_SOL,
    Currency_RLY,
    Currency_AXS,
    Currency_ADA,
    Currency_STORJ,
    Currency_ICP,
    Currency_IOTX,
    Currency_CRV,
    Currency_FET,
    Currency_POLY,
    Currency_MKN,
    Currency_MIR,
    Currency_PAX,
    Currency_MATIC,
    Currency_ANKR,
    Currency_OGN,
    Currency_RLC,
    Currency_TRB,
    Currency_ORN,
    Currency_CTSI,
    Currency_YFII,
    Currency_BOND,
    Currency_CLV,
    Currency_TRIBE,
    Currency_ACH,
    Currency_PLA,
    Currency_QUICK,
    Currency_MLN,
    Currency_QNT,
    Currency_LPT,
    Currency_KEEP,
    Currency_RAI,
    Currency_NKN,
    Currency_AMP,
    Currency_FARM,
    Currency_SHIB,
    Currency_XYO,
    Currency_RGT,
    Currency_BTRST,
    Currency_AGLD,
    Currency_ZEN
  };
  return values;
}

inline const char * const *EnumNamesCurrency() {
  static const char * const names[108] = {
    "UNKNOWN",
    "BAT",
    "BCH",
    "BTC",
    "CVC",
    "DAI",
    "DNT",
    "EOS",
    "ETC",
    "ETH",
    "EUR",
    "GBP",
    "GNT",
    "LINK",
    "LOOM",
    "LTC",
    "MANA",
    "REP",
    "USD",
    "USDC",
    "XLM",
    "XRP",
    "ZEC",
    "ZRX",
    "XTZ",
    "ALGO",
    "DASH",
    "OXT",
    "ATOM",
    "KNC",
    "OMG",
    "MKR",
    "WBTC",
    "NU",
    "YFI",
    "BAND",
    "UMA",
    "NMR",
    "FIL",
    "CGLD",
    "LRC",
    "COMP",
    "UNI",
    "REN",
    "BAL",
    "GRT",
    "BNT",
    "AAVE",
    "SNX",
    "WLUNA",
    "DOGE",
    "RAD",
    "GTC",
    "TRU",
    "SUSHI",
    "SKL",
    "COTI",
    "REQ",
    "FORTH",
    "ENJ",
    "USDT",
    "DOT",
    "CHZ",
    "UST",
    "MASK",
    "DDX",
    "SOL",
    "RLY",
    "AXS",
    "ADA",
    "STORJ",
    "ICP",
    "IOTX",
    "CRV",
    "FET",
    "POLY",
    "MKN",
    "MIR",
    "PAX",
    "MATIC",
    "ANKR",
    "OGN",
    "RLC",
    "TRB",
    "ORN",
    "CTSI",
    "YFII",
    "BOND",
    "CLV",
    "TRIBE",
    "ACH",
    "PLA",
    "QUICK",
    "MLN",
    "QNT",
    "LPT",
    "KEEP",
    "RAI",
    "NKN",
    "AMP",
    "FARM",
    "SHIB",
    "XYO",
    "RGT",
    "BTRST",
    "AGLD",
    "ZEN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurrency(Currency e) {
  if (flatbuffers::IsOutRange(e, Currency_UNKNOWN, Currency_ZEN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurrency()[index];
}

enum RequestType {
  RequestType_INVALID = 0,
  RequestType_ALL = 1,
  RequestType_ID = 2,
  RequestType_EXCHANGE = 3,
  RequestType_PRODUCT = 4,
  RequestType_MIN = RequestType_INVALID,
  RequestType_MAX = RequestType_PRODUCT
};

inline const RequestType (&EnumValuesRequestType())[5] {
  static const RequestType values[] = {
    RequestType_INVALID,
    RequestType_ALL,
    RequestType_ID,
    RequestType_EXCHANGE,
    RequestType_PRODUCT
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[6] = {
    "INVALID",
    "ALL",
    "ID",
    "EXCHANGE",
    "PRODUCT",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType_INVALID, RequestType_PRODUCT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum RiskRequestType {
  RiskRequestType_ALL = 0,
  RiskRequestType_TRADER = 1,
  RiskRequestType_SECURITY_ID = 2,
  RiskRequestType_BOOK = 3,
  RiskRequestType_MIN = RiskRequestType_ALL,
  RiskRequestType_MAX = RiskRequestType_BOOK
};

inline const RiskRequestType (&EnumValuesRiskRequestType())[4] {
  static const RiskRequestType values[] = {
    RiskRequestType_ALL,
    RiskRequestType_TRADER,
    RiskRequestType_SECURITY_ID,
    RiskRequestType_BOOK
  };
  return values;
}

inline const char * const *EnumNamesRiskRequestType() {
  static const char * const names[5] = {
    "ALL",
    "TRADER",
    "SECURITY_ID",
    "BOOK",
    nullptr
  };
  return names;
}

inline const char *EnumNameRiskRequestType(RiskRequestType e) {
  if (flatbuffers::IsOutRange(e, RiskRequestType_ALL, RiskRequestType_BOOK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRiskRequestType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SnapshotPriceLevel FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t price_;
  int64_t quantity_;

 public:
  SnapshotPriceLevel() {
    memset(static_cast<void *>(this), 0, sizeof(SnapshotPriceLevel));
  }
  SnapshotPriceLevel(int64_t _price, int64_t _quantity)
      : price_(flatbuffers::EndianScalar(_price)),
        quantity_(flatbuffers::EndianScalar(_quantity)) {
  }
  int64_t price() const {
    return flatbuffers::EndianScalar(price_);
  }
  int64_t quantity() const {
    return flatbuffers::EndianScalar(quantity_);
  }
};
FLATBUFFERS_STRUCT_END(SnapshotPriceLevel, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) IncrementalPriceLevel FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t price_;
  int64_t quantity_;
  int64_t side_;

 public:
  IncrementalPriceLevel() {
    memset(static_cast<void *>(this), 0, sizeof(IncrementalPriceLevel));
  }
  IncrementalPriceLevel(int64_t _price, int64_t _quantity, int64_t _side)
      : price_(flatbuffers::EndianScalar(_price)),
        quantity_(flatbuffers::EndianScalar(_quantity)),
        side_(flatbuffers::EndianScalar(_side)) {
  }
  int64_t price() const {
    return flatbuffers::EndianScalar(price_);
  }
  int64_t quantity() const {
    return flatbuffers::EndianScalar(quantity_);
  }
  int64_t side() const {
    return flatbuffers::EndianScalar(side_);
  }
};
FLATBUFFERS_STRUCT_END(IncrementalPriceLevel, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t timestamp_;
  int64_t security_id_;
  double position_;
  double pnl_;
  double mark_price_;

 public:
  Position() {
    memset(static_cast<void *>(this), 0, sizeof(Position));
  }
  Position(int64_t _timestamp, int64_t _security_id, double _position, double _pnl, double _mark_price)
      : timestamp_(flatbuffers::EndianScalar(_timestamp)),
        security_id_(flatbuffers::EndianScalar(_security_id)),
        position_(flatbuffers::EndianScalar(_position)),
        pnl_(flatbuffers::EndianScalar(_pnl)),
        mark_price_(flatbuffers::EndianScalar(_mark_price)) {
  }
  int64_t timestamp() const {
    return flatbuffers::EndianScalar(timestamp_);
  }
  int64_t security_id() const {
    return flatbuffers::EndianScalar(security_id_);
  }
  double position() const {
    return flatbuffers::EndianScalar(position_);
  }
  double pnl() const {
    return flatbuffers::EndianScalar(pnl_);
  }
  double mark_price() const {
    return flatbuffers::EndianScalar(mark_price_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 40);

struct Empty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmptyBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyBuilder {
  typedef Empty Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmptyBuilder &operator=(const EmptyBuilder &);
  flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline flatbuffers::Offset<Empty> CreateEmpty(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SequenceNumber FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SequenceNumberBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct SequenceNumberBuilder {
  typedef SequenceNumber Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(SequenceNumber::VT_VALUE, value, 0);
  }
  explicit SequenceNumberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceNumberBuilder &operator=(const SequenceNumberBuilder &);
  flatbuffers::Offset<SequenceNumber> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceNumber>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceNumber> CreateSequenceNumber(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  SequenceNumberBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Heartbeat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SECURITY_ID = 4,
    VT_TIMESTAMP = 6
  };
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct HeartbeatBuilder {
  typedef Heartbeat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Heartbeat::VT_SECURITY_ID, security_id, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Heartbeat::VT_TIMESTAMP, timestamp, 0);
  }
  explicit HeartbeatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeartbeatBuilder &operator=(const HeartbeatBuilder &);
  flatbuffers::Offset<Heartbeat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Heartbeat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Heartbeat> CreateHeartbeat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t security_id = 0,
    int64_t timestamp = 0) {
  HeartbeatBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_security_id(security_id);
  return builder_.Finish();
}

struct Instrument FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstrumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_SYMBOL = 8,
    VT_EXCHANGE = 10,
    VT_EXCHANGE_SYMBOL = 12,
    VT_TICK_SIZE = 14,
    VT_MIN_SIZE = 16,
    VT_MAX_SIZE = 18,
    VT_CRYPTO_BASE = 20,
    VT_CRYPTO_QUOTE = 22,
    VT_ACTIVE = 24,
    VT_SANDBOX_ENABLED = 26
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  krypto::serialization::InstrumentType type() const {
    return static_cast<krypto::serialization::InstrumentType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  krypto::serialization::Exchange exchange() const {
    return static_cast<krypto::serialization::Exchange>(GetField<int8_t>(VT_EXCHANGE, 0));
  }
  const flatbuffers::String *exchange_symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE_SYMBOL);
  }
  double tick_size() const {
    return GetField<double>(VT_TICK_SIZE, 0.0);
  }
  double min_size() const {
    return GetField<double>(VT_MIN_SIZE, 0.0);
  }
  double max_size() const {
    return GetField<double>(VT_MAX_SIZE, 0.0);
  }
  krypto::serialization::Currency crypto_base() const {
    return static_cast<krypto::serialization::Currency>(GetField<int8_t>(VT_CRYPTO_BASE, 0));
  }
  krypto::serialization::Currency crypto_quote() const {
    return static_cast<krypto::serialization::Currency>(GetField<int8_t>(VT_CRYPTO_QUOTE, 0));
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool sandbox_enabled() const {
    return GetField<uint8_t>(VT_SANDBOX_ENABLED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<int8_t>(verifier, VT_EXCHANGE) &&
           VerifyOffset(verifier, VT_EXCHANGE_SYMBOL) &&
           verifier.VerifyString(exchange_symbol()) &&
           VerifyField<double>(verifier, VT_TICK_SIZE) &&
           VerifyField<double>(verifier, VT_MIN_SIZE) &&
           VerifyField<double>(verifier, VT_MAX_SIZE) &&
           VerifyField<int8_t>(verifier, VT_CRYPTO_BASE) &&
           VerifyField<int8_t>(verifier, VT_CRYPTO_QUOTE) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_SANDBOX_ENABLED) &&
           verifier.EndTable();
  }
};

struct InstrumentBuilder {
  typedef Instrument Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(Instrument::VT_ID, id, 0);
  }
  void add_type(krypto::serialization::InstrumentType type) {
    fbb_.AddElement<int8_t>(Instrument::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Instrument::VT_SYMBOL, symbol);
  }
  void add_exchange(krypto::serialization::Exchange exchange) {
    fbb_.AddElement<int8_t>(Instrument::VT_EXCHANGE, static_cast<int8_t>(exchange), 0);
  }
  void add_exchange_symbol(flatbuffers::Offset<flatbuffers::String> exchange_symbol) {
    fbb_.AddOffset(Instrument::VT_EXCHANGE_SYMBOL, exchange_symbol);
  }
  void add_tick_size(double tick_size) {
    fbb_.AddElement<double>(Instrument::VT_TICK_SIZE, tick_size, 0.0);
  }
  void add_min_size(double min_size) {
    fbb_.AddElement<double>(Instrument::VT_MIN_SIZE, min_size, 0.0);
  }
  void add_max_size(double max_size) {
    fbb_.AddElement<double>(Instrument::VT_MAX_SIZE, max_size, 0.0);
  }
  void add_crypto_base(krypto::serialization::Currency crypto_base) {
    fbb_.AddElement<int8_t>(Instrument::VT_CRYPTO_BASE, static_cast<int8_t>(crypto_base), 0);
  }
  void add_crypto_quote(krypto::serialization::Currency crypto_quote) {
    fbb_.AddElement<int8_t>(Instrument::VT_CRYPTO_QUOTE, static_cast<int8_t>(crypto_quote), 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(Instrument::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_sandbox_enabled(bool sandbox_enabled) {
    fbb_.AddElement<uint8_t>(Instrument::VT_SANDBOX_ENABLED, static_cast<uint8_t>(sandbox_enabled), 0);
  }
  explicit InstrumentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentBuilder &operator=(const InstrumentBuilder &);
  flatbuffers::Offset<Instrument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instrument>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instrument> CreateInstrument(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    krypto::serialization::InstrumentType type = krypto::serialization::InstrumentType_UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    krypto::serialization::Exchange exchange = krypto::serialization::Exchange_SIM,
    flatbuffers::Offset<flatbuffers::String> exchange_symbol = 0,
    double tick_size = 0.0,
    double min_size = 0.0,
    double max_size = 0.0,
    krypto::serialization::Currency crypto_base = krypto::serialization::Currency_UNKNOWN,
    krypto::serialization::Currency crypto_quote = krypto::serialization::Currency_UNKNOWN,
    bool active = false,
    bool sandbox_enabled = false) {
  InstrumentBuilder builder_(_fbb);
  builder_.add_max_size(max_size);
  builder_.add_min_size(min_size);
  builder_.add_tick_size(tick_size);
  builder_.add_id(id);
  builder_.add_exchange_symbol(exchange_symbol);
  builder_.add_symbol(symbol);
  builder_.add_sandbox_enabled(sandbox_enabled);
  builder_.add_active(active);
  builder_.add_crypto_quote(crypto_quote);
  builder_.add_crypto_base(crypto_base);
  builder_.add_exchange(exchange);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Instrument> CreateInstrumentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    krypto::serialization::InstrumentType type = krypto::serialization::InstrumentType_UNKNOWN,
    const char *symbol = nullptr,
    krypto::serialization::Exchange exchange = krypto::serialization::Exchange_SIM,
    const char *exchange_symbol = nullptr,
    double tick_size = 0.0,
    double min_size = 0.0,
    double max_size = 0.0,
    krypto::serialization::Currency crypto_base = krypto::serialization::Currency_UNKNOWN,
    krypto::serialization::Currency crypto_quote = krypto::serialization::Currency_UNKNOWN,
    bool active = false,
    bool sandbox_enabled = false) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto exchange_symbol__ = exchange_symbol ? _fbb.CreateString(exchange_symbol) : 0;
  return krypto::serialization::CreateInstrument(
      _fbb,
      id,
      type,
      symbol__,
      exchange,
      exchange_symbol__,
      tick_size,
      min_size,
      max_size,
      crypto_base,
      crypto_quote,
      active,
      sandbox_enabled);
}

struct Quote FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuoteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_BID = 8,
    VT_ASK = 10,
    VT_LAST = 12,
    VT_BID_QUANTITY = 14,
    VT_ASK_QUANTITY = 16,
    VT_LAST_QUANTITY = 18
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t bid() const {
    return GetField<int64_t>(VT_BID, 0);
  }
  int64_t ask() const {
    return GetField<int64_t>(VT_ASK, 0);
  }
  int64_t last() const {
    return GetField<int64_t>(VT_LAST, 0);
  }
  int64_t bid_quantity() const {
    return GetField<int64_t>(VT_BID_QUANTITY, 0);
  }
  int64_t ask_quantity() const {
    return GetField<int64_t>(VT_ASK_QUANTITY, 0);
  }
  int64_t last_quantity() const {
    return GetField<int64_t>(VT_LAST_QUANTITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_BID) &&
           VerifyField<int64_t>(verifier, VT_ASK) &&
           VerifyField<int64_t>(verifier, VT_LAST) &&
           VerifyField<int64_t>(verifier, VT_BID_QUANTITY) &&
           VerifyField<int64_t>(verifier, VT_ASK_QUANTITY) &&
           VerifyField<int64_t>(verifier, VT_LAST_QUANTITY) &&
           verifier.EndTable();
  }
};

struct QuoteBuilder {
  typedef Quote Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Quote::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Quote::VT_SECURITY_ID, security_id, 0);
  }
  void add_bid(int64_t bid) {
    fbb_.AddElement<int64_t>(Quote::VT_BID, bid, 0);
  }
  void add_ask(int64_t ask) {
    fbb_.AddElement<int64_t>(Quote::VT_ASK, ask, 0);
  }
  void add_last(int64_t last) {
    fbb_.AddElement<int64_t>(Quote::VT_LAST, last, 0);
  }
  void add_bid_quantity(int64_t bid_quantity) {
    fbb_.AddElement<int64_t>(Quote::VT_BID_QUANTITY, bid_quantity, 0);
  }
  void add_ask_quantity(int64_t ask_quantity) {
    fbb_.AddElement<int64_t>(Quote::VT_ASK_QUANTITY, ask_quantity, 0);
  }
  void add_last_quantity(int64_t last_quantity) {
    fbb_.AddElement<int64_t>(Quote::VT_LAST_QUANTITY, last_quantity, 0);
  }
  explicit QuoteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuoteBuilder &operator=(const QuoteBuilder &);
  flatbuffers::Offset<Quote> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quote>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quote> CreateQuote(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t bid = 0,
    int64_t ask = 0,
    int64_t last = 0,
    int64_t bid_quantity = 0,
    int64_t ask_quantity = 0,
    int64_t last_quantity = 0) {
  QuoteBuilder builder_(_fbb);
  builder_.add_last_quantity(last_quantity);
  builder_.add_ask_quantity(ask_quantity);
  builder_.add_bid_quantity(bid_quantity);
  builder_.add_last(last);
  builder_.add_ask(ask);
  builder_.add_bid(bid);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct Snapshot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnapshotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_BIDS = 8,
    VT_ASKS = 10
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  const flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *> *bids() const {
    return GetPointer<const flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *> *>(VT_BIDS);
  }
  const flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *> *asks() const {
    return GetPointer<const flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *> *>(VT_ASKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           verifier.EndTable();
  }
};

struct SnapshotBuilder {
  typedef Snapshot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Snapshot::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Snapshot::VT_SECURITY_ID, security_id, 0);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *>> bids) {
    fbb_.AddOffset(Snapshot::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *>> asks) {
    fbb_.AddOffset(Snapshot::VT_ASKS, asks);
  }
  explicit SnapshotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SnapshotBuilder &operator=(const SnapshotBuilder &);
  flatbuffers::Offset<Snapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Snapshot>(end);
    return o;
  }
};

inline flatbuffers::Offset<Snapshot> CreateSnapshot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::SnapshotPriceLevel *>> asks = 0) {
  SnapshotBuilder builder_(_fbb);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  return builder_.Finish();
}

inline flatbuffers::Offset<Snapshot> CreateSnapshotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    const std::vector<krypto::serialization::SnapshotPriceLevel> *bids = nullptr,
    const std::vector<krypto::serialization::SnapshotPriceLevel> *asks = nullptr) {
  auto bids__ = bids ? _fbb.CreateVectorOfStructs<krypto::serialization::SnapshotPriceLevel>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVectorOfStructs<krypto::serialization::SnapshotPriceLevel>(*asks) : 0;
  return krypto::serialization::CreateSnapshot(
      _fbb,
      timestamp,
      security_id,
      bids__,
      asks__);
}

struct Incremental FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IncrementalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_UPDATES = 8
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  const flatbuffers::Vector<const krypto::serialization::IncrementalPriceLevel *> *updates() const {
    return GetPointer<const flatbuffers::Vector<const krypto::serialization::IncrementalPriceLevel *> *>(VT_UPDATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyVector(updates()) &&
           verifier.EndTable();
  }
};

struct IncrementalBuilder {
  typedef Incremental Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Incremental::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Incremental::VT_SECURITY_ID, security_id, 0);
  }
  void add_updates(flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::IncrementalPriceLevel *>> updates) {
    fbb_.AddOffset(Incremental::VT_UPDATES, updates);
  }
  explicit IncrementalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IncrementalBuilder &operator=(const IncrementalBuilder &);
  flatbuffers::Offset<Incremental> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Incremental>(end);
    return o;
  }
};

inline flatbuffers::Offset<Incremental> CreateIncremental(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::IncrementalPriceLevel *>> updates = 0) {
  IncrementalBuilder builder_(_fbb);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_updates(updates);
  return builder_.Finish();
}

inline flatbuffers::Offset<Incremental> CreateIncrementalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    const std::vector<krypto::serialization::IncrementalPriceLevel> *updates = nullptr) {
  auto updates__ = updates ? _fbb.CreateVectorOfStructs<krypto::serialization::IncrementalPriceLevel>(*updates) : 0;
  return krypto::serialization::CreateIncremental(
      _fbb,
      timestamp,
      security_id,
      updates__);
}

struct Trade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_PRICE = 8,
    VT_QUANTITY = 10,
    VT_SIDE = 12,
    VT_TRADE_ID = 14
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t price() const {
    return GetField<int64_t>(VT_PRICE, 0);
  }
  int64_t quantity() const {
    return GetField<int64_t>(VT_QUANTITY, 0);
  }
  krypto::serialization::Side side() const {
    return static_cast<krypto::serialization::Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  const flatbuffers::String *trade_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRADE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_PRICE) &&
           VerifyField<int64_t>(verifier, VT_QUANTITY) &&
           VerifyField<int8_t>(verifier, VT_SIDE) &&
           VerifyOffset(verifier, VT_TRADE_ID) &&
           verifier.VerifyString(trade_id()) &&
           verifier.EndTable();
  }
};

struct TradeBuilder {
  typedef Trade Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Trade::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Trade::VT_SECURITY_ID, security_id, 0);
  }
  void add_price(int64_t price) {
    fbb_.AddElement<int64_t>(Trade::VT_PRICE, price, 0);
  }
  void add_quantity(int64_t quantity) {
    fbb_.AddElement<int64_t>(Trade::VT_QUANTITY, quantity, 0);
  }
  void add_side(krypto::serialization::Side side) {
    fbb_.AddElement<int8_t>(Trade::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  void add_trade_id(flatbuffers::Offset<flatbuffers::String> trade_id) {
    fbb_.AddOffset(Trade::VT_TRADE_ID, trade_id);
  }
  explicit TradeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeBuilder &operator=(const TradeBuilder &);
  flatbuffers::Offset<Trade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Trade>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trade> CreateTrade(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    krypto::serialization::Side side = krypto::serialization::Side_UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> trade_id = 0) {
  TradeBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_trade_id(trade_id);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<Trade> CreateTradeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    krypto::serialization::Side side = krypto::serialization::Side_UNKNOWN,
    const char *trade_id = nullptr) {
  auto trade_id__ = trade_id ? _fbb.CreateString(trade_id) : 0;
  return krypto::serialization::CreateTrade(
      _fbb,
      timestamp,
      security_id,
      price,
      quantity,
      side,
      trade_id__);
}

struct InstrumentRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstrumentRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  krypto::serialization::RequestType type() const {
    return static_cast<krypto::serialization::RequestType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct InstrumentRequestBuilder {
  typedef InstrumentRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(krypto::serialization::RequestType type) {
    fbb_.AddElement<int8_t>(InstrumentRequest::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit InstrumentRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentRequestBuilder &operator=(const InstrumentRequestBuilder &);
  flatbuffers::Offset<InstrumentRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstrumentRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstrumentRequest> CreateInstrumentRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    krypto::serialization::RequestType type = krypto::serialization::RequestType_INVALID) {
  InstrumentRequestBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct InstrumentResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstrumentResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::Instrument>> *instruments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::Instrument>> *>(VT_INSTRUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTRUMENTS) &&
           verifier.VerifyVector(instruments()) &&
           verifier.VerifyVectorOfTables(instruments()) &&
           verifier.EndTable();
  }
};

struct InstrumentResponseBuilder {
  typedef InstrumentResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instruments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::Instrument>>> instruments) {
    fbb_.AddOffset(InstrumentResponse::VT_INSTRUMENTS, instruments);
  }
  explicit InstrumentResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentResponseBuilder &operator=(const InstrumentResponseBuilder &);
  flatbuffers::Offset<InstrumentResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstrumentResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstrumentResponse> CreateInstrumentResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::Instrument>>> instruments = 0) {
  InstrumentResponseBuilder builder_(_fbb);
  builder_.add_instruments(instruments);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstrumentResponse> CreateInstrumentResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<krypto::serialization::Instrument>> *instruments = nullptr) {
  auto instruments__ = instruments ? _fbb.CreateVector<flatbuffers::Offset<krypto::serialization::Instrument>>(*instruments) : 0;
  return krypto::serialization::CreateInstrumentResponse(
      _fbb,
      instruments__);
}

struct InstrumentRefreshRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstrumentRefreshRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InstrumentRefreshRequestBuilder {
  typedef InstrumentRefreshRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InstrumentRefreshRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentRefreshRequestBuilder &operator=(const InstrumentRefreshRequestBuilder &);
  flatbuffers::Offset<InstrumentRefreshRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstrumentRefreshRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstrumentRefreshRequest> CreateInstrumentRefreshRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InstrumentRefreshRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OrderRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_PRICE = 8,
    VT_QUANTITY = 10,
    VT_SIDE = 12,
    VT_ORDER_ID = 14,
    VT_TIF = 16,
    VT_TRADER = 18,
    VT_BOOK = 20
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t price() const {
    return GetField<int64_t>(VT_PRICE, 0);
  }
  int64_t quantity() const {
    return GetField<int64_t>(VT_QUANTITY, 0);
  }
  krypto::serialization::Side side() const {
    return static_cast<krypto::serialization::Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  krypto::serialization::TimeInForce tif() const {
    return static_cast<krypto::serialization::TimeInForce>(GetField<int8_t>(VT_TIF, 0));
  }
  const flatbuffers::String *trader() const {
    return GetPointer<const flatbuffers::String *>(VT_TRADER);
  }
  const flatbuffers::String *book() const {
    return GetPointer<const flatbuffers::String *>(VT_BOOK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_PRICE) &&
           VerifyField<int64_t>(verifier, VT_QUANTITY) &&
           VerifyField<int8_t>(verifier, VT_SIDE) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyField<int8_t>(verifier, VT_TIF) &&
           VerifyOffset(verifier, VT_TRADER) &&
           verifier.VerifyString(trader()) &&
           VerifyOffset(verifier, VT_BOOK) &&
           verifier.VerifyString(book()) &&
           verifier.EndTable();
  }
};

struct OrderRequestBuilder {
  typedef OrderRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_SECURITY_ID, security_id, 0);
  }
  void add_price(int64_t price) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_PRICE, price, 0);
  }
  void add_quantity(int64_t quantity) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_QUANTITY, quantity, 0);
  }
  void add_side(krypto::serialization::Side side) {
    fbb_.AddElement<int8_t>(OrderRequest::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderRequest::VT_ORDER_ID, order_id);
  }
  void add_tif(krypto::serialization::TimeInForce tif) {
    fbb_.AddElement<int8_t>(OrderRequest::VT_TIF, static_cast<int8_t>(tif), 0);
  }
  void add_trader(flatbuffers::Offset<flatbuffers::String> trader) {
    fbb_.AddOffset(OrderRequest::VT_TRADER, trader);
  }
  void add_book(flatbuffers::Offset<flatbuffers::String> book) {
    fbb_.AddOffset(OrderRequest::VT_BOOK, book);
  }
  explicit OrderRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderRequestBuilder &operator=(const OrderRequestBuilder &);
  flatbuffers::Offset<OrderRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderRequest> CreateOrderRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    krypto::serialization::Side side = krypto::serialization::Side_UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> order_id = 0,
    krypto::serialization::TimeInForce tif = krypto::serialization::TimeInForce_DAY,
    flatbuffers::Offset<flatbuffers::String> trader = 0,
    flatbuffers::Offset<flatbuffers::String> book = 0) {
  OrderRequestBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_book(book);
  builder_.add_trader(trader);
  builder_.add_order_id(order_id);
  builder_.add_tif(tif);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderRequest> CreateOrderRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    krypto::serialization::Side side = krypto::serialization::Side_UNKNOWN,
    const char *order_id = nullptr,
    krypto::serialization::TimeInForce tif = krypto::serialization::TimeInForce_DAY,
    const char *trader = nullptr,
    const char *book = nullptr) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  auto trader__ = trader ? _fbb.CreateString(trader) : 0;
  auto book__ = book ? _fbb.CreateString(book) : 0;
  return krypto::serialization::CreateOrderRequest(
      _fbb,
      timestamp,
      security_id,
      price,
      quantity,
      side,
      order_id__,
      tif,
      trader__,
      book__);
}

struct OrderCancelRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderCancelRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_ORDER_ID = 6
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           verifier.EndTable();
  }
};

struct OrderCancelRequestBuilder {
  typedef OrderCancelRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderCancelRequest::VT_TIMESTAMP, timestamp, 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderCancelRequest::VT_ORDER_ID, order_id);
  }
  explicit OrderCancelRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderCancelRequestBuilder &operator=(const OrderCancelRequestBuilder &);
  flatbuffers::Offset<OrderCancelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderCancelRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderCancelRequest> CreateOrderCancelRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0) {
  OrderCancelRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_order_id(order_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderCancelRequest> CreateOrderCancelRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const char *order_id = nullptr) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return krypto::serialization::CreateOrderCancelRequest(
      _fbb,
      timestamp,
      order_id__);
}

struct OrderReplaceRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderReplaceRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_ORDER_ID = 6,
    VT_PRICE = 8,
    VT_QUANTITY = 10,
    VT_SIDE = 12
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  int64_t price() const {
    return GetField<int64_t>(VT_PRICE, 0);
  }
  int64_t quantity() const {
    return GetField<int64_t>(VT_QUANTITY, 0);
  }
  krypto::serialization::Side side() const {
    return static_cast<krypto::serialization::Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyField<int64_t>(verifier, VT_PRICE) &&
           VerifyField<int64_t>(verifier, VT_QUANTITY) &&
           VerifyField<int8_t>(verifier, VT_SIDE) &&
           verifier.EndTable();
  }
};

struct OrderReplaceRequestBuilder {
  typedef OrderReplaceRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderReplaceRequest::VT_TIMESTAMP, timestamp, 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderReplaceRequest::VT_ORDER_ID, order_id);
  }
  void add_price(int64_t price) {
    fbb_.AddElement<int64_t>(OrderReplaceRequest::VT_PRICE, price, 0);
  }
  void add_quantity(int64_t quantity) {
    fbb_.AddElement<int64_t>(OrderReplaceRequest::VT_QUANTITY, quantity, 0);
  }
  void add_side(krypto::serialization::Side side) {
    fbb_.AddElement<int8_t>(OrderReplaceRequest::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  explicit OrderReplaceRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderReplaceRequestBuilder &operator=(const OrderReplaceRequestBuilder &);
  flatbuffers::Offset<OrderReplaceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderReplaceRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderReplaceRequest> CreateOrderReplaceRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    krypto::serialization::Side side = krypto::serialization::Side_UNKNOWN) {
  OrderReplaceRequestBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_timestamp(timestamp);
  builder_.add_order_id(order_id);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderReplaceRequest> CreateOrderReplaceRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const char *order_id = nullptr,
    int64_t price = 0,
    int64_t quantity = 0,
    krypto::serialization::Side side = krypto::serialization::Side_UNKNOWN) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return krypto::serialization::CreateOrderReplaceRequest(
      _fbb,
      timestamp,
      order_id__,
      price,
      quantity,
      side);
}

struct OrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_ORDER_ID = 6,
    VT_EXCHANGE_ORDER_ID = 8,
    VT_STATUS = 10,
    VT_FILLED_QUANTITY = 12,
    VT_FILLED_PRICE = 14
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  const flatbuffers::String *exchange_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE_ORDER_ID);
  }
  krypto::serialization::OrderStatus status() const {
    return static_cast<krypto::serialization::OrderStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  int64_t filled_quantity() const {
    return GetField<int64_t>(VT_FILLED_QUANTITY, 0);
  }
  int64_t filled_price() const {
    return GetField<int64_t>(VT_FILLED_PRICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyOffset(verifier, VT_EXCHANGE_ORDER_ID) &&
           verifier.VerifyString(exchange_order_id()) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<int64_t>(verifier, VT_FILLED_QUANTITY) &&
           VerifyField<int64_t>(verifier, VT_FILLED_PRICE) &&
           verifier.EndTable();
  }
};

struct OrderUpdateBuilder {
  typedef OrderUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderUpdate::VT_ORDER_ID, order_id);
  }
  void add_exchange_order_id(flatbuffers::Offset<flatbuffers::String> exchange_order_id) {
    fbb_.AddOffset(OrderUpdate::VT_EXCHANGE_ORDER_ID, exchange_order_id);
  }
  void add_status(krypto::serialization::OrderStatus status) {
    fbb_.AddElement<int8_t>(OrderUpdate::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_filled_quantity(int64_t filled_quantity) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_FILLED_QUANTITY, filled_quantity, 0);
  }
  void add_filled_price(int64_t filled_price) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_FILLED_PRICE, filled_price, 0);
  }
  explicit OrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderUpdateBuilder &operator=(const OrderUpdateBuilder &);
  flatbuffers::Offset<OrderUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange_order_id = 0,
    krypto::serialization::OrderStatus status = krypto::serialization::OrderStatus_UNKNOWN,
    int64_t filled_quantity = 0,
    int64_t filled_price = 0) {
  OrderUpdateBuilder builder_(_fbb);
  builder_.add_filled_price(filled_price);
  builder_.add_filled_quantity(filled_quantity);
  builder_.add_timestamp(timestamp);
  builder_.add_exchange_order_id(exchange_order_id);
  builder_.add_order_id(order_id);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const char *order_id = nullptr,
    const char *exchange_order_id = nullptr,
    krypto::serialization::OrderStatus status = krypto::serialization::OrderStatus_UNKNOWN,
    int64_t filled_quantity = 0,
    int64_t filled_price = 0) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  auto exchange_order_id__ = exchange_order_id ? _fbb.CreateString(exchange_order_id) : 0;
  return krypto::serialization::CreateOrderUpdate(
      _fbb,
      timestamp,
      order_id__,
      exchange_order_id__,
      status,
      filled_quantity,
      filled_price);
}

struct Order FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST = 4,
    VT_UPDATES = 6,
    VT_FEES = 8
  };
  const krypto::serialization::OrderRequest *request() const {
    return GetPointer<const krypto::serialization::OrderRequest *>(VT_REQUEST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::OrderUpdate>> *updates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::OrderUpdate>> *>(VT_UPDATES);
  }
  double fees() const {
    return GetField<double>(VT_FEES, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyVector(updates()) &&
           verifier.VerifyVectorOfTables(updates()) &&
           VerifyField<double>(verifier, VT_FEES) &&
           verifier.EndTable();
  }
};

struct OrderBuilder {
  typedef Order Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_request(flatbuffers::Offset<krypto::serialization::OrderRequest> request) {
    fbb_.AddOffset(Order::VT_REQUEST, request);
  }
  void add_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::OrderUpdate>>> updates) {
    fbb_.AddOffset(Order::VT_UPDATES, updates);
  }
  void add_fees(double fees) {
    fbb_.AddElement<double>(Order::VT_FEES, fees, 0.0);
  }
  explicit OrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderBuilder &operator=(const OrderBuilder &);
  flatbuffers::Offset<Order> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Order>(end);
    return o;
  }
};

inline flatbuffers::Offset<Order> CreateOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<krypto::serialization::OrderRequest> request = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::OrderUpdate>>> updates = 0,
    double fees = 0.0) {
  OrderBuilder builder_(_fbb);
  builder_.add_fees(fees);
  builder_.add_updates(updates);
  builder_.add_request(request);
  return builder_.Finish();
}

inline flatbuffers::Offset<Order> CreateOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<krypto::serialization::OrderRequest> request = 0,
    const std::vector<flatbuffers::Offset<krypto::serialization::OrderUpdate>> *updates = nullptr,
    double fees = 0.0) {
  auto updates__ = updates ? _fbb.CreateVector<flatbuffers::Offset<krypto::serialization::OrderUpdate>>(*updates) : 0;
  return krypto::serialization::CreateOrder(
      _fbb,
      request,
      updates__,
      fees);
}

struct TraderPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TraderPositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRADER = 4,
    VT_POSITIONS = 6
  };
  const flatbuffers::String *trader() const {
    return GetPointer<const flatbuffers::String *>(VT_TRADER);
  }
  const flatbuffers::Vector<const krypto::serialization::Position *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const krypto::serialization::Position *> *>(VT_POSITIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRADER) &&
           verifier.VerifyString(trader()) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           verifier.EndTable();
  }
};

struct TraderPositionBuilder {
  typedef TraderPosition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trader(flatbuffers::Offset<flatbuffers::String> trader) {
    fbb_.AddOffset(TraderPosition::VT_TRADER, trader);
  }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::Position *>> positions) {
    fbb_.AddOffset(TraderPosition::VT_POSITIONS, positions);
  }
  explicit TraderPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TraderPositionBuilder &operator=(const TraderPositionBuilder &);
  flatbuffers::Offset<TraderPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TraderPosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<TraderPosition> CreateTraderPosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> trader = 0,
    flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::Position *>> positions = 0) {
  TraderPositionBuilder builder_(_fbb);
  builder_.add_positions(positions);
  builder_.add_trader(trader);
  return builder_.Finish();
}

inline flatbuffers::Offset<TraderPosition> CreateTraderPositionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *trader = nullptr,
    const std::vector<krypto::serialization::Position> *positions = nullptr) {
  auto trader__ = trader ? _fbb.CreateString(trader) : 0;
  auto positions__ = positions ? _fbb.CreateVectorOfStructs<krypto::serialization::Position>(*positions) : 0;
  return krypto::serialization::CreateTraderPosition(
      _fbb,
      trader__,
      positions__);
}

struct BookPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BookPositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOK = 4,
    VT_POSITIONS = 6
  };
  const flatbuffers::String *book() const {
    return GetPointer<const flatbuffers::String *>(VT_BOOK);
  }
  const flatbuffers::Vector<const krypto::serialization::Position *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const krypto::serialization::Position *> *>(VT_POSITIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BOOK) &&
           verifier.VerifyString(book()) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           verifier.EndTable();
  }
};

struct BookPositionBuilder {
  typedef BookPosition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_book(flatbuffers::Offset<flatbuffers::String> book) {
    fbb_.AddOffset(BookPosition::VT_BOOK, book);
  }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::Position *>> positions) {
    fbb_.AddOffset(BookPosition::VT_POSITIONS, positions);
  }
  explicit BookPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BookPositionBuilder &operator=(const BookPositionBuilder &);
  flatbuffers::Offset<BookPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BookPosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<BookPosition> CreateBookPosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> book = 0,
    flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::Position *>> positions = 0) {
  BookPositionBuilder builder_(_fbb);
  builder_.add_positions(positions);
  builder_.add_book(book);
  return builder_.Finish();
}

inline flatbuffers::Offset<BookPosition> CreateBookPositionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *book = nullptr,
    const std::vector<krypto::serialization::Position> *positions = nullptr) {
  auto book__ = book ? _fbb.CreateString(book) : 0;
  auto positions__ = positions ? _fbb.CreateVectorOfStructs<krypto::serialization::Position>(*positions) : 0;
  return krypto::serialization::CreateBookPosition(
      _fbb,
      book__,
      positions__);
}

struct RiskSummary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiskSummaryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_POSITIONS = 6,
    VT_TRADER_POSITIONS = 8,
    VT_BOOK_POSITIONS = 10,
    VT_PNL = 12
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<const krypto::serialization::Position *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const krypto::serialization::Position *> *>(VT_POSITIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::TraderPosition>> *trader_positions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::TraderPosition>> *>(VT_TRADER_POSITIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::BookPosition>> *book_positions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::BookPosition>> *>(VT_BOOK_POSITIONS);
  }
  double pnl() const {
    return GetField<double>(VT_PNL, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           VerifyOffset(verifier, VT_TRADER_POSITIONS) &&
           verifier.VerifyVector(trader_positions()) &&
           verifier.VerifyVectorOfTables(trader_positions()) &&
           VerifyOffset(verifier, VT_BOOK_POSITIONS) &&
           verifier.VerifyVector(book_positions()) &&
           verifier.VerifyVectorOfTables(book_positions()) &&
           VerifyField<double>(verifier, VT_PNL) &&
           verifier.EndTable();
  }
};

struct RiskSummaryBuilder {
  typedef RiskSummary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(RiskSummary::VT_TIMESTAMP, timestamp, 0);
  }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::Position *>> positions) {
    fbb_.AddOffset(RiskSummary::VT_POSITIONS, positions);
  }
  void add_trader_positions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::TraderPosition>>> trader_positions) {
    fbb_.AddOffset(RiskSummary::VT_TRADER_POSITIONS, trader_positions);
  }
  void add_book_positions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::BookPosition>>> book_positions) {
    fbb_.AddOffset(RiskSummary::VT_BOOK_POSITIONS, book_positions);
  }
  void add_pnl(double pnl) {
    fbb_.AddElement<double>(RiskSummary::VT_PNL, pnl, 0.0);
  }
  explicit RiskSummaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RiskSummaryBuilder &operator=(const RiskSummaryBuilder &);
  flatbuffers::Offset<RiskSummary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiskSummary>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiskSummary> CreateRiskSummary(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<const krypto::serialization::Position *>> positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::TraderPosition>>> trader_positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<krypto::serialization::BookPosition>>> book_positions = 0,
    double pnl = 0.0) {
  RiskSummaryBuilder builder_(_fbb);
  builder_.add_pnl(pnl);
  builder_.add_timestamp(timestamp);
  builder_.add_book_positions(book_positions);
  builder_.add_trader_positions(trader_positions);
  builder_.add_positions(positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<RiskSummary> CreateRiskSummaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const std::vector<krypto::serialization::Position> *positions = nullptr,
    const std::vector<flatbuffers::Offset<krypto::serialization::TraderPosition>> *trader_positions = nullptr,
    const std::vector<flatbuffers::Offset<krypto::serialization::BookPosition>> *book_positions = nullptr,
    double pnl = 0.0) {
  auto positions__ = positions ? _fbb.CreateVectorOfStructs<krypto::serialization::Position>(*positions) : 0;
  auto trader_positions__ = trader_positions ? _fbb.CreateVector<flatbuffers::Offset<krypto::serialization::TraderPosition>>(*trader_positions) : 0;
  auto book_positions__ = book_positions ? _fbb.CreateVector<flatbuffers::Offset<krypto::serialization::BookPosition>>(*book_positions) : 0;
  return krypto::serialization::CreateRiskSummary(
      _fbb,
      timestamp,
      positions__,
      trader_positions__,
      book_positions__,
      pnl);
}

struct RiskSummaryRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiskSummaryRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TRADER = 6,
    VT_SECURITY_ID = 8,
    VT_BOOK = 10
  };
  krypto::serialization::RiskRequestType type() const {
    return static_cast<krypto::serialization::RiskRequestType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *trader() const {
    return GetPointer<const flatbuffers::String *>(VT_TRADER);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  const flatbuffers::String *book() const {
    return GetPointer<const flatbuffers::String *>(VT_BOOK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_TRADER) &&
           verifier.VerifyString(trader()) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyOffset(verifier, VT_BOOK) &&
           verifier.VerifyString(book()) &&
           verifier.EndTable();
  }
};

struct RiskSummaryRequestBuilder {
  typedef RiskSummaryRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(krypto::serialization::RiskRequestType type) {
    fbb_.AddElement<int8_t>(RiskSummaryRequest::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_trader(flatbuffers::Offset<flatbuffers::String> trader) {
    fbb_.AddOffset(RiskSummaryRequest::VT_TRADER, trader);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(RiskSummaryRequest::VT_SECURITY_ID, security_id, 0);
  }
  void add_book(flatbuffers::Offset<flatbuffers::String> book) {
    fbb_.AddOffset(RiskSummaryRequest::VT_BOOK, book);
  }
  explicit RiskSummaryRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RiskSummaryRequestBuilder &operator=(const RiskSummaryRequestBuilder &);
  flatbuffers::Offset<RiskSummaryRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiskSummaryRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiskSummaryRequest> CreateRiskSummaryRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    krypto::serialization::RiskRequestType type = krypto::serialization::RiskRequestType_ALL,
    flatbuffers::Offset<flatbuffers::String> trader = 0,
    int64_t security_id = 0,
    flatbuffers::Offset<flatbuffers::String> book = 0) {
  RiskSummaryRequestBuilder builder_(_fbb);
  builder_.add_security_id(security_id);
  builder_.add_book(book);
  builder_.add_trader(trader);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RiskSummaryRequest> CreateRiskSummaryRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    krypto::serialization::RiskRequestType type = krypto::serialization::RiskRequestType_ALL,
    const char *trader = nullptr,
    int64_t security_id = 0,
    const char *book = nullptr) {
  auto trader__ = trader ? _fbb.CreateString(trader) : 0;
  auto book__ = book ? _fbb.CreateString(book) : 0;
  return krypto::serialization::CreateRiskSummaryRequest(
      _fbb,
      type,
      trader__,
      security_id,
      book__);
}

struct TheoreticalSnapshot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TheoreticalSnapshotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_PRICE = 8,
    VT_ADJUSTED_PRICE = 10,
    VT_ERROR = 12,
    VT_MM_BASE_BID = 14,
    VT_MM_BASE_ASK = 16,
    VT_MM_BASE_SPREAD = 18,
    VT_BID_LIQUIDITY = 20,
    VT_ASK_LIQUIDITY = 22
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  double adjusted_price() const {
    return GetField<double>(VT_ADJUSTED_PRICE, 0.0);
  }
  double error() const {
    return GetField<double>(VT_ERROR, 0.0);
  }
  double mm_base_bid() const {
    return GetField<double>(VT_MM_BASE_BID, 0.0);
  }
  double mm_base_ask() const {
    return GetField<double>(VT_MM_BASE_ASK, 0.0);
  }
  double mm_base_spread() const {
    return GetField<double>(VT_MM_BASE_SPREAD, 0.0);
  }
  double bid_liquidity() const {
    return GetField<double>(VT_BID_LIQUIDITY, 0.0);
  }
  double ask_liquidity() const {
    return GetField<double>(VT_ASK_LIQUIDITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<double>(verifier, VT_PRICE) &&
           VerifyField<double>(verifier, VT_ADJUSTED_PRICE) &&
           VerifyField<double>(verifier, VT_ERROR) &&
           VerifyField<double>(verifier, VT_MM_BASE_BID) &&
           VerifyField<double>(verifier, VT_MM_BASE_ASK) &&
           VerifyField<double>(verifier, VT_MM_BASE_SPREAD) &&
           VerifyField<double>(verifier, VT_BID_LIQUIDITY) &&
           VerifyField<double>(verifier, VT_ASK_LIQUIDITY) &&
           verifier.EndTable();
  }
};

struct TheoreticalSnapshotBuilder {
  typedef TheoreticalSnapshot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(TheoreticalSnapshot::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(TheoreticalSnapshot::VT_SECURITY_ID, security_id, 0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_PRICE, price, 0.0);
  }
  void add_adjusted_price(double adjusted_price) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_ADJUSTED_PRICE, adjusted_price, 0.0);
  }
  void add_error(double error) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_ERROR, error, 0.0);
  }
  void add_mm_base_bid(double mm_base_bid) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_MM_BASE_BID, mm_base_bid, 0.0);
  }
  void add_mm_base_ask(double mm_base_ask) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_MM_BASE_ASK, mm_base_ask, 0.0);
  }
  void add_mm_base_spread(double mm_base_spread) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_MM_BASE_SPREAD, mm_base_spread, 0.0);
  }
  void add_bid_liquidity(double bid_liquidity) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_BID_LIQUIDITY, bid_liquidity, 0.0);
  }
  void add_ask_liquidity(double ask_liquidity) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_ASK_LIQUIDITY, ask_liquidity, 0.0);
  }
  explicit TheoreticalSnapshotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TheoreticalSnapshotBuilder &operator=(const TheoreticalSnapshotBuilder &);
  flatbuffers::Offset<TheoreticalSnapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TheoreticalSnapshot>(end);
    return o;
  }
};

inline flatbuffers::Offset<TheoreticalSnapshot> CreateTheoreticalSnapshot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    double price = 0.0,
    double adjusted_price = 0.0,
    double error = 0.0,
    double mm_base_bid = 0.0,
    double mm_base_ask = 0.0,
    double mm_base_spread = 0.0,
    double bid_liquidity = 0.0,
    double ask_liquidity = 0.0) {
  TheoreticalSnapshotBuilder builder_(_fbb);
  builder_.add_ask_liquidity(ask_liquidity);
  builder_.add_bid_liquidity(bid_liquidity);
  builder_.add_mm_base_spread(mm_base_spread);
  builder_.add_mm_base_ask(mm_base_ask);
  builder_.add_mm_base_bid(mm_base_bid);
  builder_.add_error(error);
  builder_.add_adjusted_price(adjusted_price);
  builder_.add_price(price);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

}  // namespace serialization
}  // namespace krypto

#endif  // FLATBUFFERS_GENERATED_SERIALIZATION_KRYPTO_SERIALIZATION_H_
